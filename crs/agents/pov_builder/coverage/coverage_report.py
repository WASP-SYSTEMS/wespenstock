"""
This is a parser for the coverage report generated by LLVM.

For the required format see.:
https://github.com/llvm/llvm-project/blob/main/llvm/tools/llvm-cov/CoverageExporterLcov.cpp
"""

import subprocess
from collections import defaultdict
from pathlib import Path
from typing import Union

from pydantic import BaseModel

from crs.base.settings import OSS_FUZZ_LOCATION
from crs.logger import CRS_LOGGER
from crscommon.logging.settings import OUTPUT_DIR

log = CRS_LOGGER.getChild(__name__)


class LineInfo(BaseModel):
    """Information about a single line of code coverage."""

    line: int
    """Line Number"""
    executions: int
    """Number of times this line was executed"""
    code: str | None = None
    """The actual source code content of the line"""
    source_file: Path | None
    """The path to the source file the line comes from"""


class BranchInfo(BaseModel):
    """Information about branch coverage for a line."""

    line: int
    """Line Number"""
    pair_index: int
    """Branch number within the line where the branch occurs"""
    true: int | None
    """Number of times the branch condition evaluated to True (can be None if branch never executed)"""
    false: int | None
    """Number of times the branch condition evaluated to False (can be None if branch never executed)"""
    code: str | None
    """The actual source code content of the *line* the branch is in. *Not the pure branch!*"""


class FunctionCoverage(BaseModel):
    """
    Coverage information for a single function.
    """

    name: str
    """Name of the function"""
    lines: dict[int, Union[LineInfo]]
    """Maps line_number (int or tuple) -> LineInfo (executions)"""
    branches: dict[int, dict[int, BranchInfo]]
    """Maps line_number -> {branch_location -> BranchInfo}"""
    source_file: Path | None
    """Path relative to source root (e.g.: src/motivational-example/sample_lib.c)"""
    num_executions: int
    """General number of how often the function was executed"""
    start_line: int
    """Number of line where the function starts"""
    # TODO: we might be able to check for function name prefixes here
    #  we have the code line and the name of the executed function, we *could* match them and detect prefixes
    # background: some projects call their functions smthng like: OSSFUZZ_project_fn (which is bad for us)

    @property
    def num_covered_lines(self) -> int:
        """Number of covered lines"""
        # the summed-list consists of True and False entries (-> 1 and 0)
        return sum(line.executions != 0 for line in self.lines.values())

    def get_code_with_coverage(self) -> str:
        """get code with coverage, see get_code_coverage_explanation() for format explanation"""

        # largest number of executions defines alignment of exec numbers
        alignment = len(str(max(line.executions for line in self.lines.values())))
        code = ""
        # this covers all lines (hopefully i didn't forget the last line in the indexing)
        for i in range(self.start_line, self.start_line + len(self.lines)):

            line = self.lines.get(i)

            # this happens on empty lines inside a function
            if line is None:
                code += "\n"
                continue

            branches = self.branches.get(i)

            branch_infos = ""
            if branches is not None:
                for b in branches.values():
                    branch_infos += f"[true: {b.true}, false: {b.false}] "
                # (alignment + ': ') as spaces + branch info + line break
                branch_infos = " " * (alignment + 2) + branch_infos.strip() + "\n"

            code += branch_infos
            # TODO: maybe an exception is a little harsh here? (maybe we can just fallback to line: cov instead?)
            if line.code is None:
                log.info(f"Code for line is None: {repr(line)}")

            # align code based on the max len of execution number (first usage of that feature in a long time :D)
            code += f"{line.executions:>{alignment}}: {line.code if line.code is not None else '<unknown code>'}\n"

        return f"```\n{code}\n```"

    @staticmethod
    def get_code_coverage_explanation() -> str:
        """Get LLM-suitable description of the provided code format, see get_code_with_coverage() for how it's built"""
        return """
The coverage format provided has the following format:
{executions}: {code line}
The example below would mean that the line was executed 10 times:
`10: int s = sum(arr);`

For conditions the condition-branch info will be provided above the line it's relating to.
Here is an example with two conditions in one line:
```
   [true: 5, false: 2] [true: 0, false: 5]
7: if (x > 5 && y < 30) {
```
This would mean that the first condition was 5 times true and 2 times false. \
While the second one was never true, but 5 times false.
The line was executed a total of 7 times, as you can determine by the "7" at the beginning of the line.

If the source code for a line is unknown it will be marked with <unknown code>, empty lines are denominated as <empty>.
        """


class FileInfo(BaseModel):
    """Overview Coverage Information about a Source File"""

    total_branches: int
    """Number of branches in the file"""
    num_hit_branches: int
    """Number of *hit* branches in the file"""
    num_lines: int
    """Number of lines in the file"""
    num_hit_lines: int
    """Number of *hit* lines in the file"""
    source_file: Path
    """Path relative to source root (e.g.: src/motivational-example/sample_lib.c)"""
    num_functions: int
    """Number of functions in the file"""
    num_functions_hit: int
    """Number of *hit* functions in the file"""


class CoverageReport(BaseModel):
    """Parsed coverage report containing line and branch information grouped by function."""

    functions: dict[str, FunctionCoverage]
    """Maps function_name -> FunctionCoverage, directly accessible using get_item"""
    file_infos: dict[Path, FileInfo]
    """"General data about the source files and their coverage"""
    coverage_report_file: Path | None = None
    """If known.: Location of the raw coverage report"""

    def __getitem__(self, function: str) -> FunctionCoverage:
        """allow for dict like access as shortcut for function coverage"""
        return self.functions[function]

    def get(self, function: str) -> FunctionCoverage | None:
        """mimics dict.get, directs to functions, returns None if entry not found"""
        return self.functions.get(function, None)

    def functions_with_coverage(self) -> list[FunctionCoverage]:
        """list of all functions that have at least some coverage"""
        return list(filter(lambda fn: fn.num_covered_lines, self.functions.values()))

    @staticmethod
    def generate_report_for_cp(
        cp_name: str, harness_id: str, reproducer_identifier: str, source_root_abs: Path | None = None
    ) -> "CoverageReport":
        """
        Runs teh command to create a coverage report and returns the parsed result
        Args:
            ctx: lol
            reproducer_identifier: the unique identifier of the reproducer that the report belongs to
        """

        res = CoverageReport.run_generate_coverage_command(cp_name, harness_id)
        try:

            cov_dir: Path = OUTPUT_DIR.get() / "coverage"
            cov_dir.mkdir(exist_ok=True)

            cov_file = cov_dir / f"coverage_{reproducer_identifier}_raw.txt"
            cov_file.write_text(res.stdout)

            log.debug(f"Written raw coverage report to: {cov_file.absolute()}")

            rep = CoverageReport.parse_coverage(res.stdout, source_root_abs=source_root_abs)
            rep.coverage_report_file = cov_file

            return rep

        except subprocess.CalledProcessError as e:
            raise RuntimeError(f"Error gathering coverage information: '{e.stderr}'") from e

    @staticmethod
    def parse_coverage_from_file(file_path: Union[str, Path]) -> "CoverageReport":
        """
        Parse an LLVM coverage report file and return a structured CoverageReport object.

        Args:
            file_path: Path to the coverage report file

        Returns:
            CoverageReport object containing parsed coverage information
        """
        file_path = Path(file_path)

        if not file_path.exists():
            raise FileNotFoundError(f"Coverage file not found: {file_path}")

        content = file_path.read_text(encoding="utf8")

        rep = CoverageReport.parse_coverage(content)
        rep.coverage_report_file = file_path
        return rep

    @staticmethod
    def parse_coverage(report: str, source_root_abs: Path | None = None) -> "CoverageReport":
        """
        Parse coverage report content string and return a structured CoverageReport object.

        Args:
            report: Raw coverage report content as string
            source_root_abs: if given the function will attempt to get the code of each line/ branch and store it

        Returns:
            CoverageReport object containing parsed coverage information
        """
        # Split content into source file sections
        sections = report.split("end_of_record")

        all_functions: dict[str, FunctionCoverage] = {}
        file_infos: dict[Path, FileInfo] = {}

        for section in sections:
            section = section.strip()
            if not section:
                continue

            # Parse each source file section
            file_functions, file_info = CoverageReport._parse_file_section(section, source_root_abs=source_root_abs)
            all_functions.update(file_functions)
            file_infos[file_info.source_file] = file_info

        return CoverageReport(functions=all_functions, file_infos=file_infos)

    @staticmethod
    def _parse_file_section(
        section: str, source_root_abs: Path | None = None
    ) -> tuple[dict[str, FunctionCoverage], FileInfo]:
        """
        Parse a single file-block from the coverage report.

        Args:
            section: Raw text content of a source file section
            source_root_abs: if given the function will attempt to get the code of each line/ branch and store it

        Returns:
            dictionary mapping function names to their coverage information
        """
        # pylint: disable=too-many-branches
        # pylint: disable=too-many-statements
        lines = section.split("\n")
        # functions from imported files are called file:function, so we only wanna split the first as key
        split_lines = [line.split(":", maxsplit=1) for line in lines]

        # a lot of data we track before we build our final data models
        # if pydantic would allow partial initialization of models this would be much easier...
        # but for that everything would need to allow None or empty values which is not great...
        source_file: Path | None = None
        source_code: list[str] | None = None
        num_branches_found: int = 0
        num_branches_hit: int = 0
        num_lines: int = 0
        num_lines_hit: int = 0
        functions_hit_total: int = 0
        functions_found_checksum: int = 0

        # general number of how often the function was executed
        function_executions: dict[str, int] = {}
        # (fn_name, start line)
        function_start_points: list[tuple[str, int]] = []

        # function -> line, branch id -> 'true'/'false', execs (int or None) (fml)
        branch_infos: defaultdict[str, dict[tuple[int, int], dict[str, int | None]]] = defaultdict(dict)
        function_lines: dict[str, list[LineInfo]] = defaultdict(list)

        def get_function_for_line_nr(_line_nr: int) -> str:
            """find out to which function a line belongs"""
            # it should be already sorted, but better safe than sorry
            start_points = sorted(function_start_points, key=lambda x: x[1])

            # check between which two function starts a line is located
            # pylint: disable=consider-using-enumerate
            for i in range(len(start_points)):
                current_fn, current_start = start_points[i]
                # it must be the last one, bc otherwise: ???
                # TODO: check that we're not in global space
                #  (we might hit global declaration at the end or maybe even between fns)
                #  there's a related todo below with some more thoughts~
                if i == len(start_points) - 1:
                    return current_fn

                _, next_start = start_points[i + 1]

                # if line is fn start or before next start, we got a match
                if current_start <= _line_nr < next_start:
                    return current_fn

            # this is only here for mypy and pycharm
            raise ValueError(f"This case can't happen, but we smh missed the mark completely with {_line_nr=}")

        # parse lines
        never_executed_branch_cnt: int = 0  # logging only
        for _line in split_lines:
            key, value = _line
            match key:
                case "SF":
                    # paths are absolute in our case bc of docker mounts e.g. /src
                    # but we want relative from source root
                    source_file = Path(value[1:])
                    log.debug(f"Source file w/o src root assumed as: {source_file}")
                    if source_root_abs is None:
                        log.warning(
                            "No (absolute) source path is provided, can't attempt to fetch code for coverage report"
                        )
                        continue

                    file = source_root_abs / source_file
                    if not file.exists():
                        log.warning(f"Can't find source file at expected location: {file.absolute()}")
                        continue

                    log.info(f"Source file found at: {file.absolute()}")

                    source_code = file.read_text().splitlines()

                case "FNDA":
                    execs, fn_name = value.split(",")
                    function_executions[fn_name] = int(execs)

                case "FN":
                    start, fn_name = value.split(",")
                    function_start_points.append((fn_name, int(start)))

                case "FNF":
                    functions_found_checksum = int(value)

                case "FNH":
                    functions_hit_total = int(value)

                case "DA":
                    split = value.split(",")

                    line_nr, exec_cnt = int(split[0]), int(split[1])
                    if len(split) == 3:
                        log.info(f"Found checksum for coverage line, ignoring it. But the value would be: '{split[2]}'")

                    related_fn = get_function_for_line_nr(line_nr)

                    # try to get source code
                    if source_code is not None:
                        try:
                            line_code = source_code[line_nr - 1]
                        except IndexError as e:
                            raise IndexError(
                                f"Can't extract {line_nr=} file {file.absolute()} with {len(source_code)=}"
                            ) from e
                    else:
                        line_code = None

                    # TODO: we could do some heuristics to sanity check if we're still in the function
                    #  for C: brackets matching, for python (and actually also C): indentation check...
                    #  this would cover the case that there are some global statements before a new fn starts...
                    #  actually.: how would the cov report handle that? are global statements even covered? :shrug:
                    function_lines[related_fn].append(
                        LineInfo(executions=exec_cnt, line=line_nr, source_file=source_file, code=line_code)
                    )

                case "BRDA":
                    # pair id: which condition in the line is meant
                    # branch id: which branch was chosen, 0: true, 1: false
                    # https://github.com/llvm/llvm-project/blob/5ef28e0a88e1dc4ce13e45c59cd77b47dd124461/llvm/tools/llvm-cov/CoverageExporterLcov.cpp#L230
                    line_nr, branch_pair_id, branch_id = map(int, value.split(",")[:3])
                    # cnt can be '-' so we have to handle it with more care
                    maybe_cnt: str = value.split(",")[3]
                    if maybe_cnt.isnumeric():
                        cnt = int(maybe_cnt)
                    else:
                        cnt = 0  # if a branch was never executed we can just count it as 0 ig
                        never_executed_branch_cnt += 1

                    related_fn = get_function_for_line_nr(line_nr)

                    _key = (line_nr, branch_pair_id)
                    sub_d: dict[str, int | None] = branch_infos[related_fn].get(_key, {})
                    sub_d["false" if branch_id else "true"] = cnt
                    branch_infos[related_fn][_key] = sub_d

                case "BRF":
                    num_branches_found = int(value)

                case "BRH":
                    num_branches_hit = int(value)

                case "LF":
                    num_lines = int(value)

                case "LH":
                    num_lines_hit = int(value)

                case "end_of_record":
                    pass

                case _:
                    raise ValueError(f"Unknown entry: {key}")

        log.info(
            f"A total of {never_executed_branch_cnt} branches were never executed, 0 was inserted for all of them "
        )

        # build data models
        fn_covs = {}
        for function in {*branch_infos.keys(), *function_lines.keys()}:
            b_infs = branch_infos[function]

            branches: defaultdict[int, dict[int, BranchInfo]] = defaultdict(dict)
            for (line_nr, pair_id), exec_infos in b_infs.items():

                if source_code is not None:
                    line_code = source_code[line_nr - 1]
                else:
                    line_code = None

                branches[line_nr][pair_id] = BranchInfo(
                    line=line_nr,
                    pair_index=pair_id,
                    true=exec_infos.get("true", 0),
                    false=exec_infos.get("false", 0),
                    code=line_code,
                )

            line_entr_dict = {}
            for line_entry in function_lines[function]:
                line_entr_dict[line_entry.line] = line_entry

            fn_cov = FunctionCoverage(
                lines=line_entr_dict,
                branches=branches,
                source_file=source_file,
                name=function,
                num_executions=function_executions[function],
                # function_start_points: list[(fn_name, start line)]
                # pylint: disable=cell-var-from-loop
                start_line=list(filter(lambda x: x[0] == function, function_start_points))[0][1],
            )

            fn_covs[fn_cov.name] = fn_cov

        assert source_file is not None

        file_info = FileInfo(
            total_branches=num_branches_found,
            num_hit_branches=num_branches_hit,
            num_lines=num_lines,
            num_hit_lines=num_lines_hit,
            source_file=source_file,
            num_functions_hit=functions_hit_total,
            num_functions=len(function_start_points),
        )

        if len(fn_covs) != functions_found_checksum:
            raise AssertionError(
                f"Expected to find {functions_found_checksum} functions (according to checksum), found {len(fn_covs)} "
                f"for coverage in file '{source_file}'."
            )

        return fn_covs, file_info

    @staticmethod
    def run_generate_coverage_command(
        cp_name: str, harness_id: str, min_line_threshold: int | None = None, function_name: str | None = None
    ) -> subprocess.CompletedProcess[str]:
        """
        assumes that reproducer was already executed, and we only need to process it
        note.: it is not clear if you can combine both optional arguments

        this function is part of create_report_from_context()

        Args:
            cp_name: lol
            harness_id: lol
            min_line_threshold: only generate report for lines with that amount of executions
            function_name: name of the function to generate coverage for
        """
        oss_dir = OSS_FUZZ_LOCATION.get()
        prof_data_file = Path(f"{oss_dir}/build/out/{cp_name}/dumps/merged.profdata")
        if not prof_data_file.exists():
            raise FileNotFoundError(f"Prof data not located at: {prof_data_file}")
        command = [
            "llvm-cov-21",
            "export",
            "-format=lcov",
            f"-instr-profile={prof_data_file}",
            f"{oss_dir}/build/out/{cp_name}/{harness_id}",
            "-path-equivalence=/,/out",
            '-ignore-filename-regex=".*src/libfuzzer/.*"',
        ]

        if min_line_threshold is not None:
            command.append(f"--line-coverage-gt={min_line_threshold}")

        if function_name is not None:
            command.append(f"--name={function_name}")
        log.debug(f"Running: {' '.join(command)}")
        return subprocess.run(command, check=True, text=True, capture_output=True)


if __name__ == "__main__":
    cov = CoverageReport.parse_coverage_from_file(Path("/data/fast/nonchris/CRS-chris/cov.txt"))
    print(cov["parse_request"])
